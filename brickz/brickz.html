<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRICKZ Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f5f9;
            --border-primary: #e2e8f0;
            --border-secondary: #cbd5e1;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --text-tertiary: #9ca3af;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --accent-blue: #3b82f6;
            --accent-blue-light: rgba(59, 130, 246, 0.2);
        }
        
        body.dark {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --border-primary: #334155;
            --border-secondary: #475569;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-tertiary: #94a3b8;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            transition: background-color 0.3s ease;
            overflow-x: hidden;
        }
        
        .brick {
            width: 32px;
            height: 32px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
        }
        
        .brick.shadow-brick {
            opacity: 1;
        }
        
        @media (max-width: 768px) {
            .brick {
                width: 24px;
                height: 24px;
            }
            
            .brick:not(.empty):after {
                width: 10px !important;
                height: 10px !important;
            }
        }
        
        .brick:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .brick.empty {
            background: #e8e8e8;
            border: 1px solid #d0d0d0;
            transition: all 0.15s ease;
        }
        
        body.dark .brick.empty {
            background: #475569;
            border: 1px solid #64748b;
        }
        
        .brick.empty:hover {
            background: #d8d8d8;
        }
        
        body.dark .brick.empty:hover {
            background: #5a6b7f;
        }
        
        /* Brick Shape Styles */
        .brick-full { border-radius: 3px; }
        .brick-tl { border-radius: 100% 3px 3px 3px; }
        .brick-tr { border-radius: 3px 100% 3px 3px; }
        .brick-br { border-radius: 3px 3px 100% 3px; }
        .brick-bl { border-radius: 3px 3px 3px 100%; }
        .brick-t { border-radius: 100% 100% 3px 3px; }
        .brick-b { border-radius: 3px 3px 100% 100%; }
        .brick-l { border-radius: 100% 3px 3px 100%; }
        .brick-r { border-radius: 3px 100% 100% 3px; }
        .brick-circle { border-radius: 50%; }
        
        /* Brick stud - removed for cleaner look */
        /*
        .brick:not(.empty):after {
            content: '';
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 14px;
            height: 14px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            pointer-events: none;
        }
        */
        
        .baseplate {
            background: var(--bg-secondary);
            padding: 24px;
            border-radius: 16px;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-primary);
            transition: all 0.3s ease;
        }
        
        @media (max-width: 768px) {
            .baseplate {
                padding: 16px;
            }
        }
        
        .grid-container {
            display: grid;
            gap: 3px;
            background: var(--bg-tertiary);
            padding: 8px;
            border-radius: 12px;
            border: 1px solid var(--border-primary);
            transition: all 0.3s ease;
        }
        
        .color-swatch {
            width: 48px;
            height: 48px;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid var(--border-primary);
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-sm);
            position: relative;
        }
        
        .color-swatch .delete-color {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 20px;
            height: 20px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            border: 2px solid var(--bg-secondary);
            z-index: 10;
        }
        
        .color-swatch:hover .delete-color {
            display: flex;
        }
        
        .color-swatch:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--border-secondary);
        }
        
        .color-swatch.selected {
            border-color: var(--accent-blue);
            border-width: 3px;
            transform: translateY(-2px);
            box-shadow: 0 0 0 3px var(--accent-blue-light), var(--shadow-md);
        }
        
        .shape-swatch {
            width: 48px;
            height: 48px;
            cursor: pointer;
            border: 2px solid var(--border-primary);
            background: #64748b;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-sm);
            position: relative;
        }
        
        .shape-swatch:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--border-secondary);
        }
        
        .shape-swatch.selected {
            border-color: var(--accent-blue);
            border-width: 3px;
            transform: translateY(-2px);
            box-shadow: 0 0 0 3px var(--accent-blue-light), var(--shadow-md);
        }
        
        /* Visual indicators for shape swatches */
        .shape-swatch.brick-full { border-radius: 4px; }
        .shape-swatch.brick-tl { border-radius: 50% 4px 4px 4px; }
        .shape-swatch.brick-tr { border-radius: 4px 50% 4px 4px; }
        .shape-swatch.brick-br { border-radius: 4px 4px 50% 4px; }
        .shape-swatch.brick-bl { border-radius: 4px 4px 4px 50%; }
        .shape-swatch.brick-t { border-radius: 50% 50% 4px 4px; }
        .shape-swatch.brick-b { border-radius: 4px 4px 50% 50%; }
        .shape-swatch.brick-l { border-radius: 50% 4px 4px 50%; }
        .shape-swatch.brick-r { border-radius: 4px 50% 50% 4px; }
        .shape-swatch.brick-circle { border-radius: 50%; }
        
        
        .tool-button {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            box-shadow: var(--shadow-sm);
        }
        
        .tool-button:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        
        .tool-button.active {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px var(--accent-blue-light), var(--shadow-sm);
        }
        
        .dark-mode-toggle {
            position: fixed;
            top: 16px;
            right: 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: all 0.3s ease;
            z-index: 100;
        }
        
        @media (max-width: 768px) {
            .dark-mode-toggle {
                width: 40px;
                height: 40px;
                top: 12px;
                right: 12px;
            }
            
            .dark-mode-toggle span {
                font-size: 20px !important;
            }
        }
        
        .dark-mode-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 12px -2px rgba(0, 0, 0, 0.2);
        }
        
        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            transition: all 0.3s ease;
        }
        
        .text-primary {
            color: var(--text-primary);
        }
        
        .text-secondary {
            color: var(--text-secondary);
        }
        
        .text-tertiary {
            color: var(--text-tertiary);
        }
        
        /* Menu Bar Styles */
        .menu-bar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            box-shadow: var(--shadow-sm);
            position: sticky;
            top: 0;
            z-index: 50;
            transition: all 0.3s ease;
        }
        
        .menu-bar button {
            padding: 8px 16px;
            font-size: 14px;
            font-weight: 600;
            border-radius: 6px;
            transition: all 0.15s ease;
            border: 1px solid transparent;
            color: var(--text-primary);
            background: transparent;
        }
        
        .menu-bar button:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-primary);
        }
        
        @media (max-width: 768px) {
            .menu-bar button {
                padding: 6px 12px;
                font-size: 12px;
            }
        }
        
        /* Mobile Responsive Styles */
        @media (max-width: 1280px) {
            .grid-cols-xl-2 {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 16px;
            }
            
            h1 {
                font-size: 2rem !important;
            }
            
            .text-lg {
                font-size: 1rem !important;
            }
            
            .panel {
                padding: 16px !important;
            }
            
            .color-swatch, .shape-swatch {
                width: 40px;
                height: 40px;
            }
            
            .grid-cols-4 {
                grid-template-columns: repeat(4, minmax(0, 1fr));
                gap: 8px;
            }
            
            .tool-button {
                padding: 8px 16px;
                font-size: 14px;
            }
            
            .canvas-controls button {
                font-size: 14px;
                padding: 8px 12px !important;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.75rem !important;
            }
            
            .grid-cols-4 {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }
            
            .canvas-controls {
                flex-direction: column;
                width: 100%;
            }
            
            .canvas-controls button {
                width: 100%;
            }
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-6 lg:p-8">
    <!-- Dark Mode Toggle -->
    <button id="dark-mode-toggle" class="dark-mode-toggle" title="Toggle dark mode">
        <span id="theme-icon" style="font-size: 24px;">üåô</span>
    </button>

    <!-- Menu Bar -->
    <div class="menu-bar">
        <div class="w-full max-w-full mx-auto px-4 sm:px-6 lg:px-8 py-3">
            <div class="flex flex-wrap items-center gap-2 justify-between">
                <div class="flex items-center gap-2">
                    <span class="text-2xl">üß±</span>
                    <h1 class="text-xl font-bold text-primary">BRICKZ Simulator</h1>
        </div>
                <div class="flex flex-wrap gap-2">
                    <button id="clear-btn" class="menu-bar-btn">
                        üóëÔ∏è Clear
                    </button>
                    <button id="fill-btn" class="menu-bar-btn">
                        üé® Fill All
                    </button>
                    <button id="recolor-btn" class="menu-bar-btn">
                        üåà Recolor
                    </button>
                    <button id="fill-empty-btn" class="menu-bar-btn">
                        ‚ú® Fill Empty
                    </button>
                    <button id="export-btn" class="menu-bar-btn">
                        üì• Export
                    </button>
                    <button id="import-btn" class="menu-bar-btn">
                        üì§ Import
                    </button>
                    <button id="import-image-btn" class="menu-bar-btn">
                        üñºÔ∏è Image
                    </button>
                    <button id="add-shadows-btn" class="menu-bar-btn">
                        üëª Add Shadows
                    </button>
                    <button id="shadow-color-btn" class="menu-bar-btn flex items-center gap-2">
                        <div id="shadow-color-preview" style="width: 16px; height: 16px; border-radius: 3px; background: #000000; border: 1px solid #ccc;"></div>
                        <span>Shadow Color</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Brick Shape Toolbar -->
    <div class="panel border-b border-t-0" style="border-radius: 0;">
        <div class="w-full max-w-full mx-auto px-4 sm:px-6 lg:px-8 py-3">
            <div class="flex items-center gap-4 flex-wrap">
                <h2 class="text-sm font-bold text-primary whitespace-nowrap">üî∑ Shape:</h2>
                <div class="flex gap-2 flex-wrap" id="shape-palette">
                    <!-- Shapes will be generated here -->
                </div>
                <div class="flex items-center gap-2 ml-4">
                    <span class="text-sm font-bold text-primary whitespace-nowrap">üõ†Ô∏è Tool:</span>
                    <button class="tool-button bg-blue-500 text-white active px-4 py-2 rounded-lg text-sm font-semibold" data-tool="place">
                            ‚ûï Place
                        </button>
                    <button class="tool-button bg-red-500 text-white px-4 py-2 rounded-lg text-sm font-semibold" data-tool="erase">
                            ‚ùå Erase
                        </button>
                </div>
                <p class="text-xs text-tertiary ml-auto whitespace-nowrap">‚å®Ô∏è Shortcuts: 1-9, 0, P, E</p>
            </div>
                    </div>
                </div>

    <div class="w-full max-w-full mx-auto" style="max-width: calc(100vw - 32px);">
    

        <div class="space-y-6 lg:space-y-8">
            <!-- Main Canvas -->
            <div class="baseplate panel min-w-0">
                <div class="overflow-x-auto">
                    <div class="grid-container" id="canvas" style="grid-template-columns: repeat(50, 32px); min-width: min-content;">
                        <!-- Grid will be generated here -->
                    </div>
                </div>
            </div>

            <!-- Sidebar Tools -->
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                <!-- Color Palette -->
                <div class="panel rounded-xl shadow-sm p-6">
                    <h2 class="text-xl font-bold text-primary mb-4">üé® Color Palette</h2>
                    <div class="grid grid-cols-4 gap-3" id="color-palette">
                        <!-- Colors will be generated here -->
                    </div>
                    <button id="add-color-btn" class="w-full mt-4 bg-purple-500 hover:bg-purple-600 text-white py-2 rounded-lg font-semibold text-sm">
                        ‚ûï Add Custom Color
                            </button>
                </div>

                <!-- Grid Size -->
                <div class="panel rounded-xl shadow-sm p-6">
                    <h2 class="text-xl font-bold text-primary mb-4">üìè Grid Size</h2>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-semibold mb-2 text-primary">Width: <span id="width-value">50</span></label>
                            <input type="range" id="width-slider" min="10" max="100" value="50" class="w-full">
                        </div>
                        <div>
                            <label class="block text-sm font-semibold mb-2 text-primary">Height: <span id="height-value">12</span></label>
                            <input type="range" id="height-slider" min="8" max="90" value="12" class="w-full">
                        </div>
                        <button id="apply-size-btn" class="w-full bg-purple-500 hover:bg-purple-600 text-white py-2 rounded-lg font-semibold">
                            Apply Size
                        </button>
                    </div>
                </div>

                <!-- Stats -->
                <div class="panel rounded-xl shadow-sm p-6">
                    <h2 class="text-xl font-bold text-primary mb-4">üìä Stats</h2>
                    <div class="space-y-2 text-sm text-primary">
                        <div class="flex justify-between">
                            <span class="font-semibold">Total Bricks:</span>
                            <span id="total-bricks">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="font-semibold">Placed:</span>
                            <span id="placed-bricks" class="font-bold" style="color: #22c55e;">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="font-semibold">Empty:</span>
                            <span id="empty-bricks" class="text-secondary">0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer Info -->
        <div class="mt-8 panel rounded-xl shadow-sm p-6">
            <h3 class="text-xl font-bold text-primary mb-3">‚å®Ô∏è Keyboard Shortcuts</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-3 text-sm text-secondary">
                <div><span class="font-semibold text-primary">1-9</span> - Select brick shape (Full, Circle, TL, TR, BR, BL, Top, Bottom, Left)</div>
                <div><span class="font-semibold text-primary">0</span> - Select Right shape</div>
                <div><span class="font-semibold text-primary">P</span> - Place mode</div>
                <div><span class="font-semibold text-primary">E</span> - Erase mode</div>
                <div><span class="font-semibold text-primary">C</span> - Clear canvas (with confirmation)</div>
                <div><span class="font-semibold text-primary">R</span> - Toggle RTL mode</div>
                <div><span class="font-semibold text-primary">D</span> - Toggle dark mode</div>
            </div>
        </div>
    </div>

    <!-- Hidden file inputs for import -->
    <input type="file" id="file-input" accept=".json" style="display: none;">
    <input type="file" id="image-input" accept="image/*" style="display: none;">

    <script>
        // Color palette - Vibrant brickz DOTS colors
        let COLORS = [
            { name: 'Hot Pink', class: '', hex: '#ec4899' },
            { name: 'Rose', class: '', hex: '#fb7185' },
            { name: 'Red', class: '', hex: '#ef4444' },
            { name: 'Orange', class: '', hex: '#f97316' },
            { name: 'Yellow', class: '', hex: '#facc15' },
            { name: 'Lime', class: '', hex: '#a3e635' },
            { name: 'Green', class: '', hex: '#22c55e' },
            { name: 'Emerald', class: '', hex: '#34d399' },
            { name: 'Cyan', class: '', hex: '#22d3ee' },
            { name: 'Sky Blue', class: '', hex: '#38bdf8' },
            { name: 'Blue', class: '', hex: '#3b82f6' },
            { name: 'Indigo', class: '', hex: '#6366f1' },
            { name: 'Purple', class: '', hex: '#a855f7' },
            { name: 'Fuchsia', class: '', hex: '#d946ef' },
            { name: 'White', class: '', hex: '#ffffff' },
            { name: 'Gray', class: '', hex: '#6b7280' }
        ];

        const SHAPES = [
            { name: 'Full', class: 'brick-full', id: 1 },
            { name: 'Circle', class: 'brick-circle', id: 6 },
            { name: 'Top-Left', class: 'brick-tl', id: 2 },
            { name: 'Top-Right', class: 'brick-tr', id: 3 },
            { name: 'Bottom-Right', class: 'brick-br', id: 4 },
            { name: 'Bottom-Left', class: 'brick-bl', id: 5 },
            { name: 'Top', class: 'brick-t', id: 7 },
            { name: 'Bottom', class: 'brick-b', id: 8 },
            { name: 'Left', class: 'brick-l', id: 9 },
            { name: 'Right', class: 'brick-r', id: 10 }
        ];

        // State
        let gridWidth = 50;
        let gridHeight = 12;
        let currentColor = COLORS[0];
        let currentShape = SHAPES[0];
        let currentTool = 'place';
        let grid = [];
        let isMouseDown = false;

        // Elements
        const canvas = document.getElementById('canvas');
        const colorPalette = document.getElementById('color-palette');
        const shapePalette = document.getElementById('shape-palette');
        const widthSlider = document.getElementById('width-slider');
        const heightSlider = document.getElementById('height-slider');
        const widthValue = document.getElementById('width-value');
        const heightValue = document.getElementById('height-value');

        // Render color palette
        function renderColorPalette() {
            colorPalette.innerHTML = '';
        COLORS.forEach((color, index) => {
            const swatch = document.createElement('div');
                swatch.className = `color-swatch ${color === currentColor ? 'selected' : ''}`;
                swatch.style.backgroundColor = color.hex;
            swatch.title = color.name;
                swatch.onclick = (e) => {
                    if (!e.target.classList.contains('delete-color')) {
                        selectColor(color, swatch);
                    }
                };
                
                // Add delete button for custom colors
                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'delete-color';
                deleteBtn.innerHTML = '‚úï';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (COLORS.length > 1) {
                        const colorIndex = COLORS.indexOf(color);
                        COLORS.splice(colorIndex, 1);
                        if (currentColor === color) {
                            currentColor = COLORS[0];
                        }
                        renderColorPalette();
                        saveColors();
                    } else {
                        alert('You need at least one color!');
                    }
                };
                swatch.appendChild(deleteBtn);
                
            colorPalette.appendChild(swatch);
        });
        }

        // Initialize color palette
        renderColorPalette();

        // Initialize shape palette
        SHAPES.forEach((shape, index) => {
            const swatch = document.createElement('div');
            swatch.className = `shape-swatch ${shape.class} ${index === 0 ? 'selected' : ''}`;
            swatch.title = shape.name;
            swatch.onclick = () => selectShape(shape, swatch);
            shapePalette.appendChild(swatch);
        });

        // Tool buttons
        document.querySelectorAll('.tool-button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
            });
        });

        // Color selection
        function selectColor(color, element) {
            currentColor = color;
            renderColorPalette();
        }

        // Save colors to localStorage
        function saveColors() {
            localStorage.setItem('customColors', JSON.stringify(COLORS));
        }

        // Load colors from localStorage
        function loadColors() {
            const saved = localStorage.getItem('customColors');
            if (saved) {
                COLORS = JSON.parse(saved);
                currentColor = COLORS[0];
            }
        }

        // Add custom color
        document.getElementById('add-color-btn').addEventListener('click', () => {
            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.value = '#000000';
            colorInput.style.display = 'none';
            document.body.appendChild(colorInput);
            
            colorInput.addEventListener('change', (e) => {
                const hex = e.target.value;
                const name = prompt('Enter a name for this color:', 'Custom Color');
                if (name) {
                    COLORS.push({ name, hex, class: '' });
                    renderColorPalette();
                    saveColors();
                }
                document.body.removeChild(colorInput);
            });
            
            colorInput.click();
        });

        // Load saved colors on startup
        loadColors();

        // Shape selection
        function selectShape(shape, element) {
            currentShape = shape;
            document.querySelectorAll('.shape-swatch').forEach(s => s.classList.remove('selected'));
            element.classList.add('selected');
        }

        // Initialize grid
        function initGrid() {
            grid = [];
            canvas.innerHTML = '';
            
            // Responsive brick size
            const isMobile = window.innerWidth <= 768;
            const brickSize = isMobile ? 24 : 32;
            canvas.style.gridTemplateColumns = `repeat(${gridWidth}, ${brickSize}px)`;
            
            for (let i = 0; i < gridHeight * gridWidth; i++) {
                const brick = document.createElement('div');
                brick.className = 'brick empty';
                brick.dataset.index = i;
                
                brick.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isMouseDown = true;
                    handleBrickClick(i, e.button === 2);
                });
                
                brick.addEventListener('mouseenter', () => {
                    if (isMouseDown) {
                        handleBrickClick(i, currentTool === 'erase');
                    }
                });
                
                brick.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    handleBrickClick(i, true);
                });
                
                canvas.appendChild(brick);
                grid.push({ color: null, shape: null });
            }
            
            updateStats();
        }

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Dark mode functionality
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const themeIcon = document.getElementById('theme-icon');
        
        // Check for saved theme preference or default to light mode
        const currentTheme = localStorage.getItem('theme') || 'light';
        if (currentTheme === 'dark') {
            document.body.classList.add('dark');
            themeIcon.textContent = '‚òÄÔ∏è';
        }
        
        function toggleDarkMode() {
            document.body.classList.toggle('dark');
            const isDark = document.body.classList.contains('dark');
            themeIcon.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }
        
        darkModeToggle.addEventListener('click', toggleDarkMode);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when typing in input fields
            if (e.target.tagName === 'INPUT') return;
            
            const key = e.key.toLowerCase();
            
            // Number keys 1-9, 0 for shapes
            if (key >= '1' && key <= '9') {
                const shapeIndex = parseInt(key) - 1;
                if (shapeIndex < SHAPES.length) {
                    const shape = SHAPES[shapeIndex];
                    const swatch = shapePalette.children[shapeIndex];
                    selectShape(shape, swatch);
                    e.preventDefault();
                }
            } else if (key === '0') {
                // 0 key for the 10th shape (Right)
                if (SHAPES.length >= 10) {
                    const shape = SHAPES[9];
                    const swatch = shapePalette.children[9];
                    selectShape(shape, swatch);
                    e.preventDefault();
                }
            }
            // P for Place mode
            else if (key === 'p') {
                currentTool = 'place';
                document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                document.querySelector('[data-tool="place"]').classList.add('active');
                e.preventDefault();
            }
            // E for Erase mode
            else if (key === 'e') {
                currentTool = 'erase';
                document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                document.querySelector('[data-tool="erase"]').classList.add('active');
                e.preventDefault();
            }
            // C for Clear (with confirmation)
            else if (key === 'c') {
                if (confirm('Are you sure you want to clear the canvas?')) {
                    initGrid();
                }
                e.preventDefault();
            }
            // D for Dark mode toggle
            else if (key === 'd') {
                toggleDarkMode();
                e.preventDefault();
            }
        });

        // Handle brick click
        function handleBrickClick(index, remove = false) {
            const brick = canvas.children[index];
            
            if (remove || currentTool === 'erase') {
                // Remove brick
                brick.className = 'brick empty';
                brick.style.backgroundColor = '';
                brick.classList.remove('shadow-brick');
                grid[index] = { color: null, shape: null, isShadow: false };
            } else {
                // Place brick
                brick.className = `brick ${currentShape.class}`;
                brick.style.backgroundColor = currentColor.hex;
                brick.classList.remove('shadow-brick');
                grid[index] = { 
                    color: currentColor,
                    shape: currentShape,
                    isShadow: false
                };
            }
            
            updateStats();
        }

        // Place shadow bricks around all placed bricks
        function addShadowsToAllBricks() {
            // First, remove any existing shadow bricks
            for (let i = 0; i < grid.length; i++) {
                if (grid[i].isShadow) {
                    const brick = canvas.children[i];
                    brick.className = 'brick empty';
                    brick.style.backgroundColor = '';
                    brick.classList.remove('shadow-brick');
                    grid[i] = { color: null, shape: null, isShadow: false };
                }
            }
            
            // Create a set of all placed brick positions
            const placedBricks = new Set();
            for (let i = 0; i < grid.length; i++) {
                if (grid[i].color !== null && !grid[i].isShadow) {
                    placedBricks.add(i);
                }
            }
            
            // Find all positions that should have shadows (only bottom-right for drop shadow effect)
            const shadowPositions = new Set();
            
            placedBricks.forEach(index => {
                const row = Math.floor(index / gridWidth);
                const col = index % gridWidth;
                
                // Only check bottom-left positions for drop shadow effect
                const offsets = [
                    [0, -1],   // left
                    [1, 0],    // bottom
                    [1, -1]    // bottom-left diagonal
                ];
                
                offsets.forEach(([rowOffset, colOffset]) => {
                    const newRow = row + rowOffset;
                    const newCol = col + colOffset;
                    
                    if (newRow >= 0 && newRow < gridHeight && newCol >= 0 && newCol < gridWidth) {
                        const newIndex = newRow * gridWidth + newCol;
                        
                        // Only add shadow if position is empty (not a placed brick)
                        if (!placedBricks.has(newIndex) && grid[newIndex].color === null) {
                            shadowPositions.add(newIndex);
                        }
                    }
                });
            });
            
            // Place shadow bricks at all shadow positions
            shadowPositions.forEach(index => {
                const shadowBrick = canvas.children[index];
                shadowBrick.className = `brick brick-full shadow-brick`;
                shadowBrick.style.backgroundColor = shadowColor;
                grid[index] = {
                    color: { hex: shadowColor, name: 'Shadow' },
                    shape: SHAPES[0], // Full shape
                    isShadow: true
                };
            });
            
            updateStats();
        }

        // Place shadow bricks around a main brick (not used anymore, kept for compatibility)
        function placeShadowBricks(centerIndex) {
            // This function is kept for compatibility but not used
            // Shadows are now added for all bricks at once via addShadowsToAllBricks()
        }

        // Update stats
        function updateStats() {
            const total = gridWidth * gridHeight;
            const placed = grid.filter(cell => cell.color !== null).length;
            const empty = total - placed;
            
            document.getElementById('total-bricks').textContent = total;
            document.getElementById('placed-bricks').textContent = placed;
            document.getElementById('empty-bricks').textContent = empty;
        }

        // Slider updates
        widthSlider.addEventListener('input', (e) => {
            widthValue.textContent = e.target.value;
        });

        heightSlider.addEventListener('input', (e) => {
            heightValue.textContent = e.target.value;
        });

        // Apply size
        document.getElementById('apply-size-btn').addEventListener('click', () => {
            const newWidth = parseInt(widthSlider.value);
            const newHeight = parseInt(heightSlider.value);
            
            // Check if we're increasing size (preserve data) or decreasing (warn user)
            if (newWidth < gridWidth || newHeight < gridHeight) {
                if (!confirm('Decreasing grid size may crop your design. Continue?')) {
                    return;
                }
            }
            
            // Save current grid data
            const oldGrid = [...grid];
            const oldWidth = gridWidth;
            const oldHeight = gridHeight;
            
            // Update dimensions
            gridWidth = newWidth;
            gridHeight = newHeight;
            
            // Create new grid with empty cells
            grid = [];
            canvas.innerHTML = '';
            
            const isMobile = window.innerWidth <= 768;
            const brickSize = isMobile ? 24 : 32;
            canvas.style.gridTemplateColumns = `repeat(${gridWidth}, ${brickSize}px)`;
            
            // Create all bricks
            for (let i = 0; i < gridHeight * gridWidth; i++) {
                const brick = document.createElement('div');
                brick.className = 'brick empty';
                brick.dataset.index = i;
                
                brick.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isMouseDown = true;
                    handleBrickClick(i, e.button === 2);
                });
                
                brick.addEventListener('mouseenter', () => {
                    if (isMouseDown) {
                        handleBrickClick(i, currentTool === 'erase');
                    }
                });
                
                brick.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    handleBrickClick(i, true);
                });
                
                canvas.appendChild(brick);
                grid.push({ color: null, shape: null });
            }
            
            // Restore old data where it fits
            for (let y = 0; y < Math.min(oldHeight, gridHeight); y++) {
                for (let x = 0; x < Math.min(oldWidth, gridWidth); x++) {
                    const oldIndex = y * oldWidth + x;
                    const newIndex = y * gridWidth + x;
                    
                    if (oldGrid[oldIndex] && oldGrid[oldIndex].color) {
                        const cellData = oldGrid[oldIndex];
                        const brick = canvas.children[newIndex];
                        brick.className = `brick ${cellData.shape.class}`;
                        brick.style.backgroundColor = cellData.color.hex;
                        grid[newIndex] = cellData;
                    }
                }
            }
            
            updateStats();
        });

        // Clear canvas
        document.getElementById('clear-btn').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear the canvas?')) {
                initGrid();
            }
        });

        // Fill all
        document.getElementById('fill-btn').addEventListener('click', () => {
            for (let i = 0; i < grid.length; i++) {
                const brick = canvas.children[i];
                brick.className = `brick ${currentShape.class}`;
                brick.style.backgroundColor = currentColor.hex;
                grid[i] = {
                    color: currentColor,
                    shape: currentShape
                };
            }
            updateStats();
        });

        // Recolor all placed bricks
        document.getElementById('recolor-btn').addEventListener('click', () => {
            let recoloredCount = 0;
            for (let i = 0; i < grid.length; i++) {
                if (grid[i].color !== null) {
                    const brick = canvas.children[i];
                    // Keep the same shape, just change the color
                    brick.className = `brick ${grid[i].shape.class}`;
                    brick.style.backgroundColor = currentColor.hex;
                    grid[i].color = currentColor;
                    recoloredCount++;
                }
            }
            updateStats();
            if (recoloredCount > 0) {
                console.log(`Recolored ${recoloredCount} bricks to ${currentColor.name}`);
            }
        });

        // Fill only empty slots with current color/shape
        document.getElementById('fill-empty-btn').addEventListener('click', () => {
            let filledCount = 0;
            for (let i = 0; i < grid.length; i++) {
                if (grid[i].color === null) {
                    const brick = canvas.children[i];
                    brick.className = `brick ${currentShape.class}`;
                    brick.style.backgroundColor = currentColor.hex;
                    grid[i] = {
                        color: currentColor,
                        shape: currentShape
                    };
                    filledCount++;
                }
            }
            updateStats();
            if (filledCount > 0) {
                console.log(`Filled ${filledCount} empty slots with ${currentColor.name}`);
            }
        });

        // Export design
        document.getElementById('export-btn').addEventListener('click', () => {
            const design = {
                width: gridWidth,
                height: gridHeight,
                grid: grid.map(cell => ({
                    color: cell.color ? cell.color.hex : null,
                    colorClass: cell.color ? cell.color.class : null,
                    shape: cell.shape ? cell.shape.class : null,
                    shapeId: cell.shape ? cell.shape.id : null
                }))
            };
            
            const blob = new Blob([JSON.stringify(design, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'brickz-design.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        // Import design
        document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });

        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const design = JSON.parse(event.target.result);
                    
                    // Apply grid size
                    gridWidth = design.width;
                    gridHeight = design.height;
                    widthSlider.value = gridWidth;
                    heightSlider.value = gridHeight;
                    widthValue.textContent = gridWidth;
                    heightValue.textContent = gridHeight;
                    
                    // Initialize grid
                    initGrid();
                    
                    // Apply design
                    design.grid.forEach((cell, index) => {
                        if (cell.color && cell.shape) {
                            let color = COLORS.find(c => c.hex === cell.color);
                            // If color not found, add it
                            if (!color) {
                                color = { name: 'Imported', hex: cell.color, class: '' };
                                COLORS.push(color);
                            }
                            const shape = SHAPES.find(s => s.class === cell.shape);
                            
                            if (color && shape) {
                                const brick = canvas.children[index];
                                brick.className = `brick ${shape.class}`;
                                brick.style.backgroundColor = color.hex;
                                grid[index] = { color, shape };
                            }
                        }
                    });
                    
                    renderColorPalette();
                    saveColors();
                    updateStats();
                    alert('Design imported successfully!');
                } catch (error) {
                    alert('Error importing design: ' + error.message);
                }
            };
            reader.readAsText(file);
            
            // Reset input
            e.target.value = '';
        });

        // Import image
        document.getElementById('import-image-btn').addEventListener('click', () => {
            document.getElementById('image-input').click();
        });

        document.getElementById('image-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    processImage(img);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            
            // Reset input
            e.target.value = '';
        });

        function processImage(img) {
            // Create a canvas to read pixel data
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            
            // Scale image to fit grid
            tempCanvas.width = gridWidth;
            tempCanvas.height = gridHeight;
            
            // Draw image scaled to canvas size
            ctx.drawImage(img, 0, 0, gridWidth, gridHeight);
            
            // Get pixel data
            const imageData = ctx.getImageData(0, 0, gridWidth, gridHeight);
            const pixels = imageData.data;
            
            // Clear current grid
            initGrid();
            
            // Convert pixels to brickz bricks
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const index = y * gridWidth + x;
                    const pixelIndex = (y * gridWidth + x) * 4;
                    
                    const r = pixels[pixelIndex];
                    const g = pixels[pixelIndex + 1];
                    const b = pixels[pixelIndex + 2];
                    const a = pixels[pixelIndex + 3];
                    
                    // Skip transparent pixels
                    if (a < 128) continue;
                    
                    // Find closest color
                    const color = findClosestColor(r, g, b);
                    
                    if (color) {
                        const brick = canvas.children[index];
                        brick.className = `brick ${currentShape.class}`;
                        brick.style.backgroundColor = color.hex;
                        grid[index] = { color, shape: currentShape };
                    }
                }
            }
            
            updateStats();
            alert('Image imported! Adjust grid size before importing if you want different dimensions.');
        }

        function findClosestColor(r, g, b) {
            let minDistance = Infinity;
            let closestColor = null;
            
            COLORS.forEach(color => {
                // Convert hex to RGB
                const hex = color.hex.replace('#', '');
                const cr = parseInt(hex.substr(0, 2), 16);
                const cg = parseInt(hex.substr(2, 2), 16);
                const cb = parseInt(hex.substr(4, 2), 16);
                
                // Calculate color distance (Euclidean distance in RGB space)
                const distance = Math.sqrt(
                    Math.pow(r - cr, 2) +
                    Math.pow(g - cg, 2) +
                    Math.pow(b - cb, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            });
            
            return closestColor;
        }

        // Handle window resize for responsive grid
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                const isMobile = window.innerWidth <= 768;
                const brickSize = isMobile ? 24 : 32;
                canvas.style.gridTemplateColumns = `repeat(${gridWidth}, ${brickSize}px)`;
            }, 250);
        });

        // Shadow functionality
        let shadowColor = localStorage.getItem('shadowColor') || '#000000';
        document.getElementById('shadow-color-preview').style.background = shadowColor;
        
        // Add shadows button
        document.getElementById('add-shadows-btn').addEventListener('click', () => {
            addShadowsToAllBricks();
        });
        
        // Shadow color picker
        document.getElementById('shadow-color-btn').addEventListener('click', () => {
            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.value = shadowColor;
            colorInput.style.display = 'none';
            document.body.appendChild(colorInput);
            
            colorInput.addEventListener('change', (e) => {
                shadowColor = e.target.value;
                document.getElementById('shadow-color-preview').style.background = shadowColor;
                localStorage.setItem('shadowColor', shadowColor);
                
                // Update all existing shadow bricks with new color
                for (let i = 0; i < grid.length; i++) {
                    if (grid[i].isShadow) {
                        const brick = canvas.children[i];
                        brick.style.backgroundColor = shadowColor;
                        grid[i].color.hex = shadowColor;
                    }
                }
                
                document.body.removeChild(colorInput);
            });
            
            colorInput.addEventListener('blur', () => {
                document.body.removeChild(colorInput);
            });
            
            colorInput.click();
        });

        // Initialize
        initGrid();
    </script>
</body>
</html>

