<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRICKZ Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f5f9;
            --border-primary: #e2e8f0;
            --border-secondary: #cbd5e1;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --text-tertiary: #9ca3af;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --accent-blue: #3b82f6;
            --accent-blue-light: rgba(59, 130, 246, 0.2);
        }
        
        body.dark {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --border-primary: #334155;
            --border-secondary: #475569;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-tertiary: #94a3b8;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            transition: background-color 0.3s ease;
            overflow-x: hidden;
        }
        
        .brick {
            width: 32px;
            height: 32px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
        }
        
        .brick.shadow-brick {
            opacity: 1;
        }
        
        @media (max-width: 768px) {
            .brick {
                width: 24px;
                height: 24px;
            }
            
            .brick:not(.empty):after {
                width: 10px !important;
                height: 10px !important;
            }
        }
        
        .brick:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .brick.empty {
            background: #e8e8e8;
            border: 1px solid #d0d0d0;
            transition: all 0.15s ease;
        }
        
        body.dark .brick.empty {
            background: #475569;
            border: 1px solid #64748b;
        }
        
        .brick.empty:hover {
            background: #d8d8d8;
        }
        
        body.dark .brick.empty:hover {
            background: #5a6b7f;
        }
        
        /* Brick Shape Styles */
        .brick-full { border-radius: 3px; }
        .brick-tl { border-radius: 100% 3px 3px 3px; }
        .brick-tr { border-radius: 3px 100% 3px 3px; }
        .brick-br { border-radius: 3px 3px 100% 3px; }
        .brick-bl { border-radius: 3px 3px 3px 100%; }
        .brick-t { border-radius: 100% 100% 3px 3px; }
        .brick-b { border-radius: 3px 3px 100% 100%; }
        .brick-l { border-radius: 100% 3px 3px 100%; }
        .brick-r { border-radius: 3px 100% 100% 3px; }
        .brick-circle { border-radius: 50%; }
        
        /* Brick stud - removed for cleaner look */
        /*
        .brick:not(.empty):after {
            content: '';
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 14px;
            height: 14px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            pointer-events: none;
        }
        */
        
        .baseplate {
            background: var(--bg-secondary);
            padding: 24px;
            border-radius: 16px;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-primary);
            transition: all 0.3s ease;
        }
        
        @media (max-width: 768px) {
            .baseplate {
                padding: 16px;
            }
        }
        
        .grid-container {
            display: grid;
            gap: 1px;
            background: var(--bg-tertiary);
            padding: 8px;
            border-radius: 12px;
            border: 1px solid var(--border-primary);
            transition: all 0.3s ease;
        }
        
        .color-swatch {
            width: 48px;
            height: 48px;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid var(--border-primary);
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-sm), inset 0 0 0 1px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        
        .color-swatch .delete-color {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 20px;
            height: 20px;
            background: #ef4444;
            color: white;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            border: 2px solid var(--bg-secondary);
            z-index: 10;
        }
        
        .color-swatch:hover .delete-color {
            display: flex;
        }
        
        /* Hide delete button on quick color palette */
        #quick-color-palette .color-swatch .delete-color {
            display: none !important;
        }
        
        /* Enhanced visibility for quick color palette swatches */
        #quick-color-palette .color-swatch {
            border: 3px solid rgba(0, 0, 0, 0.6) !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        #quick-color-palette .color-swatch.selected {
            border: 3px solid var(--accent-blue) !important;
        }
        
        /* Selected stamp highlight */
        .stamp-selected {
            border-color: var(--accent-blue) !important;
            border-width: 3px !important;
            transform: translateY(-2px) !important;
            box-shadow: 0 0 0 3px var(--accent-blue-light), var(--shadow-md) !important;
        }
        
        .color-swatch:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--border-secondary);
        }
        
        .color-swatch.selected {
            border-color: var(--accent-blue);
            border-width: 3px;
            transform: translateY(-2px);
            box-shadow: 0 0 0 3px var(--accent-blue-light), var(--shadow-md);
        }
        
        .shape-swatch {
            width: 48px;
            height: 48px;
            cursor: pointer;
            border: 2px solid var(--border-primary);
            background: #64748b;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-sm);
            position: relative;
        }
        
        .shape-swatch:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--border-secondary);
        }
        
        .shape-swatch.selected {
            border-color: var(--accent-blue);
            border-width: 3px;
            transform: translateY(-2px);
            box-shadow: 0 0 0 3px var(--accent-blue-light), var(--shadow-md);
        }
        
        /* Visual indicators for shape swatches */
        .shape-swatch.brick-full { border-radius: 4px; }
        .shape-swatch.brick-tl { border-radius: 50% 4px 4px 4px; }
        .shape-swatch.brick-tr { border-radius: 4px 50% 4px 4px; }
        .shape-swatch.brick-br { border-radius: 4px 4px 50% 4px; }
        .shape-swatch.brick-bl { border-radius: 4px 4px 4px 50%; }
        .shape-swatch.brick-t { border-radius: 50% 50% 4px 4px; }
        .shape-swatch.brick-b { border-radius: 4px 4px 50% 50%; }
        .shape-swatch.brick-l { border-radius: 50% 4px 4px 50%; }
        .shape-swatch.brick-r { border-radius: 4px 50% 50% 4px; }
        .shape-swatch.brick-circle { border-radius: 50%; }
        
        
        .tool-button {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid transparent;
            box-shadow: var(--shadow-sm);
        }
        
        .tool-button:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }
        
        .tool-button.active {
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 3px var(--accent-blue-light), var(--shadow-sm);
        }
        
        .dark-mode-toggle {
            position: fixed;
            top: 16px;
            right: 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            width: 44px;
            height: 44px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: all 0.3s ease;
            z-index: 100;
        }
        
        @media (max-width: 768px) {
            .dark-mode-toggle {
                width: 40px;
                height: 40px;
                top: 12px;
                right: 12px;
            }
            
            .dark-mode-toggle span {
                font-size: 20px !important;
            }
        }
        
        .dark-mode-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 12px -2px rgba(0, 0, 0, 0.2);
        }
        
        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            transition: all 0.3s ease;
        }
        
        .text-primary {
            color: var(--text-primary);
        }
        
        .text-secondary {
            color: var(--text-secondary);
        }
        
        .text-tertiary {
            color: var(--text-tertiary);
        }
        
        /* Menu Bar Styles */
        .menu-bar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-primary);
            box-shadow: var(--shadow-sm);
            position: sticky;
            top: 0;
            z-index: 50;
            transition: all 0.3s ease;
        }
        
        .menu-bar button,
        .menu-bar-btn {
            padding-left: 16px !important;
            padding-right: 16px !important;
            padding-top: 8px !important;
            padding-bottom: 8px !important;
            font-size: 14px;
            font-weight: 600;
            border-radius: 8px;
            transition: all 0.15s ease;
            border: 1.5px solid rgba(0, 0, 0, 0.15);
            color: var(--text-primary);
            background: var(--bg-secondary);
        }
        
        .menu-bar button:hover,
        .menu-bar-btn:hover {
            background: rgba(255, 255, 255, 1);
            border-color: rgba(0, 0, 0, 0.25);
            transform: translateY(-1px);
        }
        
        @media (max-width: 768px) {
            .menu-bar button {
                padding-left: 12px !important;
                padding-right: 12px !important;
                padding-top: 6px !important;
                padding-bottom: 6px !important;
                font-size: 12px;
            }
        }
        
        /* Mobile Responsive Styles */
        @media (max-width: 1280px) {
            .grid-cols-xl-2 {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 16px;
            }
            
            h1 {
                font-size: 2rem !important;
            }
            
            .text-lg {
                font-size: 1rem !important;
            }
            
            .panel {
                padding: 16px !important;
            }
            
            .color-swatch, .shape-swatch {
                width: 40px;
                height: 40px;
            }
            
            .grid-cols-4 {
                grid-template-columns: repeat(4, minmax(0, 1fr));
                gap: 8px;
            }
            
            .tool-button {
                padding: 8px 16px;
                font-size: 14px;
            }
            
            .canvas-controls button {
                font-size: 14px;
                padding: 8px 12px !important;
            }
        }
        
        @media (max-width: 480px) {
            h1 {
                font-size: 1.75rem !important;
            }
            
            .grid-cols-4 {
                grid-template-columns: repeat(3, minmax(0, 1fr));
            }
            
            .canvas-controls {
                flex-direction: column;
                width: 100%;
            }
            
            .canvas-controls button {
                width: 100%;
            }
        }
    </style>
</head>
<body class="min-h-screen p-4 sm:p-6 lg:p-8">
    <!-- Dark Mode Toggle -->
    <button id="dark-mode-toggle" class="dark-mode-toggle" title="Toggle dark mode">
        <span id="theme-icon" style="font-size: 24px;">◑</span>
    </button>

    <!-- Brick Shape Toolbar (moved to top) -->
    <div class="menu-bar">
        <div class="w-full max-w-full mx-auto px-4 sm:px-6 lg:px-8 py-3">
            <div class="flex items-center gap-4 flex-wrap">
                <div class="flex items-center gap-2">
                    <h1 class="text-xl font-bold text-primary">BRICKZ Simulator</h1>
                </div>
                <div class="flex items-center gap-2">
                    <h2 class="text-sm font-bold text-primary whitespace-nowrap"></h2>
                    <div class="flex gap-2 flex-wrap" id="shape-palette">
                        <!-- Shapes will be generated here -->
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <h2 class="text-sm font-bold text-primary whitespace-nowrap"></h2>
                    <div class="flex gap-2" id="quick-color-palette">
                        <!-- Quick colors will be generated here -->
                    </div>
                </div>
                <div class="flex items-center gap-2">
                    <button class="tool-button menu-bar-btn text-white active px-4 py-2 rounded-lg text-sm font-semibold" data-tool="place">
                        Place
                    </button>
                    <button class="tool-button menu-bar-btn text-white px-4 py-2 rounded-lg text-sm font-semibold" data-tool="erase">
                        Erase
                    </button>
                </div>
                <p class="text-xs text-tertiary ml-auto whitespace-nowrap">Shortcuts: 1-9, 0, P, E</p>
            </div>
        </div>
    </div>

    <!-- Menu Bar (moved to second position) -->
    <div class="panel border-b border-t-0" style="border-radius: 0;">
        <div class="w-full max-w-full mx-auto px-4 sm:px-6 lg:px-8 py-3">
            <div class="flex flex-wrap items-center gap-3 justify-between">
                <div class="flex flex-wrap gap-3">
                    <button id="undo-btn" class="menu-bar-btn" title="Undo (Ctrl+Z)">
                        Undo
                    </button>
                    <button id="redo-btn" class="menu-bar-btn" title="Redo (Ctrl+Y)">
                        Redo
                    </button>
                    <button id="clear-btn" class="menu-bar-btn">
                        Clear
                    </button>
                    <button id="fill-btn" class="menu-bar-btn">
                        Fill All
                    </button>
                    <button id="recolor-btn" class="menu-bar-btn">
                        Recolor
                    </button>
                    <button id="fill-empty-btn" class="menu-bar-btn">
                        Fill Empty
                    </button>
                    <button id="import-image-btn" class="menu-bar-btn">
                        Image
                    </button>
                    <button id="add-shadows-btn" class="menu-bar-btn">
                        Add Shadows
                    </button>
                    <button id="shadow-color-btn" class="menu-bar-btn flex items-center gap-2">
                        <div id="shadow-color-preview" style="width: 16px; height: 16px; border-radius: 3px; background: #000000; border: 1px solid #ccc;"></div>
                        <span>Shadow Color</span>
                    </button>
                    <button id="baseplate-color-btn" class="menu-bar-btn flex items-center gap-2">
                        <div id="baseplate-color-preview" style="width: 16px; height: 16px; border-radius: 3px; border: 1px solid #ccc;"></div>
                        <span>Baseplate Color</span>
                    </button>
                </div>
                <div class="flex flex-wrap gap-3">
                    <button id="export-png-btn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold text-sm">
                        Export PNG
                    </button>
                    <button id="export-btn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold text-sm">
                        Export JSON
                    </button>
                    <button id="import-btn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg font-semibold text-sm">
                        Import JSON
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="w-full max-w-full mx-auto" style="max-width: calc(100vw - 32px);">
    

        <div class="space-y-6 lg:space-y-8">
            <!-- Main Canvas -->
            <div class="baseplate panel min-w-0">
                <div class="overflow-x-auto">
                    <div class="grid-container" id="canvas" style="grid-template-columns: repeat(50, 32px); min-width: min-content;">
                        <!-- Grid will be generated here -->
                    </div>
                </div>
            </div>

            <!-- Sidebar Tools -->
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- Color Palette -->
                <div class="panel rounded-xl shadow-sm p-6">
                    <h2 class="text-xl font-bold text-primary mb-4">Color Palette</h2>
                    <div class="grid grid-cols-4 gap-3" id="color-palette">
                        <!-- Colors will be generated here -->
                    </div>
                    <button id="add-color-btn" class="w-full mt-4 bg-blue-500 hover:bg-blue-600 text-white py-2 rounded-lg font-semibold text-sm">
                        Add Custom Color
                            </button>
                </div>

                <!-- Stamp Inventory -->
                <div class="panel rounded-xl shadow-sm p-6">
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-xl font-bold text-primary">Stamp Inventory</h2>
                        <div class="flex gap-2">
                            <button id="import-shapes-btn" class="text-primary hover:text-blue-500 px-2 py-1 rounded-lg text-sm transition-colors border border-gray-400">
                                Import
                            </button>
                            <button id="export-shapes-btn" class="text-primary hover:text-blue-500 px-2 py-1 rounded-lg text-sm transition-colors border border-gray-400">
                                Export
                            </button>
                            <button id="save-template-btn" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1.5 rounded-lg font-semibold text-sm">
                                Save Stamp
                            </button>
                        </div>
                    </div>
                    <div class="grid grid-cols-4 gap-3" id="shape-inventory">
                        <!-- Custom stamps will be generated here -->
                    </div>
                    <div class="flex gap-2 mt-4">
                        <button id="clear-stamps-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white py-2 rounded-lg font-semibold text-sm">
                            Clear All Stamps
                        </button>
                    </div>
                </div>

                <!-- Grid Size -->
                <div class="panel rounded-xl shadow-sm p-6">
                    <h2 class="text-xl font-bold text-primary mb-4">Grid Size</h2>
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-semibold mb-2 text-primary">Width: <span id="width-value">50</span></label>
                            <input type="range" id="width-slider" min="10" max="100" value="50" class="w-full">
                        </div>
                        <div>
                            <label class="block text-sm font-semibold mb-2 text-primary">Height: <span id="height-value">12</span></label>
                            <input type="range" id="height-slider" min="8" max="90" value="12" class="w-full">
                        </div>
                        <button id="apply-size-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white py-2 rounded-lg font-semibold">
                            Apply Size
                        </button>
                    </div>
                </div>

            </div>
        </div>

        <!-- Footer Info -->
        <div class="mt-8 panel rounded-xl shadow-sm p-6">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Keyboard Shortcuts -->
                <div>
                    <h3 class="text-xl font-bold text-primary mb-3">Keyboard Shortcuts</h3>
                    <div class="grid grid-cols-1 gap-2 text-sm text-secondary">
                        <div><span class="font-semibold text-primary">1-9</span> - Select brick shape (Full, Circle, TL, TR, BR, BL, Top, Bottom, Left)</div>
                        <div><span class="font-semibold text-primary">0</span> - Select Right shape</div>
                        <div><span class="font-semibold text-primary">P</span> - Place mode</div>
                        <div><span class="font-semibold text-primary">E</span> - Erase mode</div>
                        <div><span class="font-semibold text-primary">C</span> - Clear canvas (with confirmation)</div>
                        <div><span class="font-semibold text-primary">Ctrl+Z</span> - Undo</div>
                        <div><span class="font-semibold text-primary">Ctrl+Y</span> - Redo</div>
                        <div><span class="font-semibold text-primary">D</span> - Toggle dark mode</div>
                    </div>
                    <div class="mt-4 flex gap-2">
                        <a href="https://github.com/amosjerbi/portfolio/blob/master/brickz/Hebrew_Font.zip" target="_blank" rel="noopener noreferrer" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 rounded-lg font-semibold text-sm text-center">
                            Download Hebrew Font
                        </a>
                        <a href="https://github.com/amosjerbi/portfolio/tree/master/brickz" target="_blank" rel="noopener noreferrer" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 rounded-lg font-semibold text-sm text-center">
                            GitHub Project
                        </a>
                    </div>
                </div>
                
                <!-- Stats -->
                <div>
                    <h3 class="text-xl font-bold text-primary mb-3">Stats</h3>
                    <div class="space-y-2 text-sm text-primary">
                        <div class="flex justify-between">
                            <span class="font-semibold">Total Bricks:</span>
                            <span id="total-bricks">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="font-semibold">Placed:</span>
                            <span id="placed-bricks" class="font-bold" style="color: #22c55e;">0</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="font-semibold">Empty:</span>
                            <span id="empty-bricks" class="text-secondary">0</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file inputs for import -->
    <input type="file" id="file-input" accept=".json" style="display: none;">
    <input type="file" id="image-input" accept="image/*" style="display: none;">
    <input type="file" id="shapes-input" accept=".json" multiple style="display: none;">

    <script>
        // Color palette - LEGO inspired colors
        const DEFAULT_COLORS = [
            { name: 'Royal Blue', class: '', hex: '#2563eb' },
            { name: 'Lavender', class: '', hex: '#b4a7d6' },
            { name: 'Red', class: '', hex: '#dc2626' },
            { name: 'Yellow', class: '', hex: '#fbbf24' },
            { name: 'Pink', class: '', hex: '#f8b4d9' }
        ];
        
        let COLORS = [...DEFAULT_COLORS];

        const DEFAULT_SHAPES = [
            { name: 'Full', class: 'brick-full', id: 1 },
            { name: 'Circle', class: 'brick-circle', id: 6 },
            { name: 'Top-Left', class: 'brick-tl', id: 2 },
            { name: 'Top-Right', class: 'brick-tr', id: 3 },
            { name: 'Bottom-Right', class: 'brick-br', id: 4 },
            { name: 'Bottom-Left', class: 'brick-bl', id: 5 },
            { name: 'Top', class: 'brick-t', id: 7 },
            { name: 'Bottom', class: 'brick-b', id: 8 },
            { name: 'Left', class: 'brick-l', id: 9 },
            { name: 'Right', class: 'brick-r', id: 10 }
        ];

        let SHAPES = [...DEFAULT_SHAPES];

        // Custom stamps (saved patterns)
        let customTemplates = [];

        // Undo/Redo history
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;

        // State
        let gridWidth = 50;
        let gridHeight = 12;
        let currentColor = COLORS[0];
        let currentShape = SHAPES[0];
        let currentTool = 'place';
        let currentTemplate = null;  // Currently selected stamp
        let grid = [];
        let isMouseDown = false;

        // Elements
        const canvas = document.getElementById('canvas');
        const colorPalette = document.getElementById('color-palette');
        const quickColorPalette = document.getElementById('quick-color-palette');
        const shapePalette = document.getElementById('shape-palette');
        const shapeInventory = document.getElementById('shape-inventory');
        const widthSlider = document.getElementById('width-slider');
        const heightSlider = document.getElementById('height-slider');
        const widthValue = document.getElementById('width-value');
        const heightValue = document.getElementById('height-value');

        // Load colors from localStorage
        function loadColors() {
            const saved = localStorage.getItem('customColors');
            if (saved) {
                COLORS = JSON.parse(saved);
                currentColor = COLORS[0];
            }
        }

        // Load saved colors BEFORE rendering palettes
        loadColors();

        // Load shapes from localStorage
        function loadShapes() {
            const saved = localStorage.getItem('customShapes');
            if (saved) {
                SHAPES = JSON.parse(saved);
            }
        }

        // Save shapes to localStorage
        function saveShapes() {
            localStorage.setItem('customShapes', JSON.stringify(SHAPES));
        }

        // Load saved shapes
        loadShapes();

        // Load stamps from localStorage
        function loadTemplates() {
            const saved = localStorage.getItem('customStamps');
            if (saved) {
                customTemplates = JSON.parse(saved);
            }
        }

        // Save stamps to localStorage
        function saveTemplates() {
            localStorage.setItem('customStamps', JSON.stringify(customTemplates));
        }

        // Load saved stamps
        loadTemplates();

        // Recent colors tracking
        let recentColors = [];
        
        // Load recent colors from localStorage
        function loadRecentColors() {
            const saved = localStorage.getItem('recentColors');
            if (saved) {
                const savedHexes = JSON.parse(saved);
                // Convert hex values back to color objects
                recentColors = savedHexes.map(hex => 
                    COLORS.find(c => c.hex === hex) || { name: 'Custom', hex, class: '' }
                ).filter(c => c); // Remove any null values
            }
            // If no recent colors, use first 4 from palette
            if (recentColors.length === 0) {
                recentColors = COLORS.slice(0, 4);
            }
        }
        
        // Save recent colors to localStorage
        function saveRecentColors() {
            const hexes = recentColors.map(c => c.hex);
            localStorage.setItem('recentColors', JSON.stringify(hexes));
        }
        
        // Load recent colors
        loadRecentColors();

        // Render color palette
        function renderColorPalette() {
            colorPalette.innerHTML = '';
        COLORS.forEach((color, index) => {
            const swatch = document.createElement('div');
                swatch.className = `color-swatch ${color.hex === currentColor.hex ? 'selected' : ''}`;
                swatch.style.backgroundColor = color.hex;
            swatch.title = color.name;
                swatch.onclick = (e) => {
                    if (!e.target.classList.contains('delete-color')) {
                        selectColor(color);
                    }
                };
                
                // Only add delete button for custom colors (not in default palette)
                const isDefaultColor = DEFAULT_COLORS.some(dc => dc.hex === color.hex);
                if (!isDefaultColor) {
                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'delete-color';
                    deleteBtn.innerHTML = '✕';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (COLORS.length > 1) {
                            const colorIndex = COLORS.indexOf(color);
                            COLORS.splice(colorIndex, 1);
                            if (currentColor === color) {
                                currentColor = COLORS[0];
                            }
                            renderColorPalette();
                            renderQuickColorPalette();
                            saveColors();
                        } else {
                            alert('You need at least one color!');
                        }
                    };
                    swatch.appendChild(deleteBtn);
                }
                
            colorPalette.appendChild(swatch);
        });
        }

        // Initialize color palette
        renderColorPalette();

        // Render quick color palette (4 most recent colors in top bar)
        function renderQuickColorPalette() {
            quickColorPalette.innerHTML = '';
            // Show most recent 4 colors
            const quickColors = recentColors.slice(0, 4);
            quickColors.forEach((color, index) => {
                const swatch = document.createElement('div');
                swatch.className = `color-swatch ${color.hex === currentColor.hex ? 'selected' : ''}`;
                swatch.style.backgroundColor = color.hex;
                swatch.title = color.name + ' (double-click to change color)';
                swatch.onclick = (e) => {
                    // Don't process if clicking on delete button
                    if (!e.target.classList.contains('delete-color')) {
                        selectColor(color);
                    }
                };
                
                // Add double-click to open color picker
                swatch.ondblclick = (e) => {
                    e.stopPropagation();
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.value = color.hex;
                    colorInput.style.display = 'none';
                    document.body.appendChild(colorInput);
                    
                    colorInput.addEventListener('change', (e) => {
                        const newHex = e.target.value.toUpperCase();
                        // Update the color in recentColors array
                        recentColors[index] = { 
                            name: `Custom ${newHex}`, 
                            hex: newHex, 
                            class: '' 
                        };
                        saveRecentColors();
                        renderQuickColorPalette();
                        renderColorPalette();
                        document.body.removeChild(colorInput);
                    });
                    
                    colorInput.click();
                };
                
                // Don't add delete button to quick palette
                // (but we need to handle if CSS shows it)
                
                quickColorPalette.appendChild(swatch);
            });
        }

        // Initialize quick color palette
        renderQuickColorPalette();

        // Render stamp inventory (only custom templates)
        function renderShapeInventory() {
            shapeInventory.innerHTML = '';
            
            // Only show custom stamps (templates)
            if (customTemplates.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.className = 'col-span-4 text-center py-8 text-secondary';
                emptyMsg.style.fontSize = '14px';
                emptyMsg.innerHTML = 'No stamps yet.<br/>Save your designs as stamps!';
                shapeInventory.appendChild(emptyMsg);
                return;
            }
            
            customTemplates.forEach((template, index) => {
                const templateSwatch = document.createElement('div');
                templateSwatch.className = 'shape-swatch stamp-swatch';
                templateSwatch.title = template.name;
                templateSwatch.style.position = 'relative';
                // Transparent background with border
                templateSwatch.style.background = 'transparent';
                templateSwatch.style.display = 'flex';
                templateSwatch.style.alignItems = 'center';
                templateSwatch.style.justifyContent = 'center';
                templateSwatch.style.width = '80px';
                templateSwatch.style.height = '60px';
                templateSwatch.style.minWidth = '80px';
                templateSwatch.style.fontSize = '14px';
                templateSwatch.style.fontWeight = '700';
                templateSwatch.style.color = 'var(--text-primary)';
                templateSwatch.style.padding = '12px';
                templateSwatch.style.textAlign = 'center';
                templateSwatch.style.overflow = 'hidden';
                templateSwatch.style.whiteSpace = 'nowrap';
                templateSwatch.style.borderRadius = '12px';
                templateSwatch.style.textOverflow = 'ellipsis';
                templateSwatch.style.lineHeight = '1.2';
                templateSwatch.textContent = template.name;
                
                // Add selected class if this is the current template
                if (currentTemplate === template) {
                    templateSwatch.classList.add('stamp-selected');
                }
                
                templateSwatch.onclick = (e) => {
                    if (!e.target.classList.contains('delete-shape')) {
                        currentTemplate = template;
                        currentTool = 'place';
                        // Update tool buttons
                        document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                        document.querySelector('[data-tool="place"]').classList.add('active');
                        // Re-render to update selection highlight
                        renderShapeInventory();
                    }
                };
                
                // Add delete button for stamps
                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'delete-color delete-shape';
                deleteBtn.innerHTML = '✕';
                deleteBtn.style.top = '-8px';
                deleteBtn.style.right = '-8px';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm(`Delete stamp "${template.name}"?`)) {
                        customTemplates.splice(index, 1);
                        if (currentTemplate === template) {
                            currentTemplate = null;
                        }
                        renderShapeInventory();
                        saveTemplates();
                    }
                };
                templateSwatch.appendChild(deleteBtn);
                
                shapeInventory.appendChild(templateSwatch);
            });
        }

        // Render shape palette (top bar)
        function renderShapePalette() {
            shapePalette.innerHTML = '';
            SHAPES.forEach((shape, index) => {
                const swatch = document.createElement('div');
                swatch.className = `shape-swatch ${shape.class} ${shape.class === currentShape.class ? 'selected' : ''}`;
                swatch.title = shape.name;
                swatch.onclick = () => selectShape(shape, swatch);
                shapePalette.appendChild(swatch);
            });
        }

        // Initialize shape palettes
        renderShapeInventory();
        renderShapePalette();

        // Tool buttons
        document.querySelectorAll('.tool-button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
                currentTemplate = null;  // Clear stamp selection when switching tools
                renderShapeInventory();  // Update stamp highlights
            });
        });

        // Color selection
        function selectColor(color) {
            currentColor = color;
            
            // Update recent colors
            // Remove color if it already exists
            recentColors = recentColors.filter(c => c.hex !== color.hex);
            // Add to front
            recentColors.unshift(color);
            // Keep only last 4
            recentColors = recentColors.slice(0, 4);
            // Save to localStorage
            saveRecentColors();
            
            renderColorPalette();
            renderQuickColorPalette();
        }

        // Save colors to localStorage
        function saveColors() {
            localStorage.setItem('customColors', JSON.stringify(COLORS));
        }

        // Add custom color
        document.getElementById('add-color-btn').addEventListener('click', () => {
            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.value = '#000000';
            colorInput.style.display = 'none';
            document.body.appendChild(colorInput);
            
            colorInput.addEventListener('change', (e) => {
                const hex = e.target.value;
                const name = prompt('Enter a name for this color:', 'Custom Color');
                if (name) {
                    COLORS.push({ name, hex, class: '' });
                    renderColorPalette();
                    renderQuickColorPalette();
                    saveColors();
                }
                document.body.removeChild(colorInput);
            });
            
            colorInput.click();
        });

        // Shape selection (deselects stamp)
        function selectShape(shape) {
            currentShape = shape;
            currentTemplate = null;  // Deselect stamp
            renderShapePalette();
            renderShapeInventory();  // Update stamp highlights
        }

        // Initialize grid
        function initGrid() {
            grid = [];
            canvas.innerHTML = '';
            
            // Responsive brick size
            const isMobile = window.innerWidth <= 768;
            const brickSize = isMobile ? 24 : 32;
            canvas.style.gridTemplateColumns = `repeat(${gridWidth}, ${brickSize}px)`;
            
            for (let i = 0; i < gridHeight * gridWidth; i++) {
                const brick = document.createElement('div');
                brick.className = 'brick empty';
                brick.dataset.index = i;
                
                // Apply custom empty brick colors if set
                if (window.emptyBrickColor) {
                    brick.style.backgroundColor = window.emptyBrickColor;
                    brick.style.borderColor = window.emptyBrickBorder;
                }
                
                brick.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isMouseDown = true;
                    handleBrickClick(i, e.button === 2);
                });
                
                brick.addEventListener('mouseenter', () => {
                    if (isMouseDown) {
                        handleBrickClick(i, currentTool === 'erase');
                    }
                });
                
                brick.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    handleBrickClick(i, true);
                });
                
                canvas.appendChild(brick);
                grid.push({ color: null, shape: null });
            }
            
            updateStats();
        }

        // Save current state to history
        function saveState() {
            // Remove any states after current index (when making new changes after undo)
            history = history.slice(0, historyIndex + 1);
            
            // Deep clone the grid
            const state = JSON.parse(JSON.stringify(grid));
            history.push(state);
            
            // Limit history size
            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }
            
            updateUndoRedoButtons();
        }

        // Restore grid from state
        function restoreState(state) {
            grid = JSON.parse(JSON.stringify(state));
            
            // Update UI
            for (let i = 0; i < grid.length; i++) {
                const brick = canvas.children[i];
                const cell = grid[i];
                
                if (cell.color && cell.shape) {
                    brick.className = `brick ${cell.shape.class}`;
                    brick.style.backgroundColor = cell.color.hex;
                    if (cell.isShadow) {
                        brick.classList.add('shadow-brick');
                    }
                } else {
                    brick.className = 'brick empty';
                    brick.style.backgroundColor = '';
                    brick.style.borderColor = '';
                    // Apply custom empty brick colors if set
                    if (window.emptyBrickColor) {
                        brick.style.backgroundColor = window.emptyBrickColor;
                        brick.style.borderColor = window.emptyBrickBorder;
                    }
                }
            }
            
            updateStats();
        }

        // Undo
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(history[historyIndex]);
                updateUndoRedoButtons();
            }
        }

        // Redo
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState(history[historyIndex]);
                updateUndoRedoButtons();
            }
        }

        // Update undo/redo button states
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undo-btn');
            const redoBtn = document.getElementById('redo-btn');
            
            if (undoBtn) {
                undoBtn.disabled = historyIndex <= 0;
                undoBtn.style.opacity = historyIndex <= 0 ? '0.5' : '1';
                undoBtn.style.cursor = historyIndex <= 0 ? 'not-allowed' : 'pointer';
            }
            
            if (redoBtn) {
                redoBtn.disabled = historyIndex >= history.length - 1;
                redoBtn.style.opacity = historyIndex >= history.length - 1 ? '0.5' : '1';
                redoBtn.style.cursor = historyIndex >= history.length - 1 ? 'not-allowed' : 'pointer';
            }
        }

        // Undo/Redo button listeners
        document.getElementById('undo-btn').addEventListener('click', undo);
        document.getElementById('redo-btn').addEventListener('click', redo);

        let wasDrawing = false;
        document.addEventListener('mousedown', () => {
            wasDrawing = false;
        });
        
        document.addEventListener('mouseup', () => {
            if (isMouseDown && wasDrawing) {
                saveState();
            }
            isMouseDown = false;
            wasDrawing = false;
        });

        // Dark mode functionality
        const darkModeToggle = document.getElementById('dark-mode-toggle');
        const themeIcon = document.getElementById('theme-icon');
        
        // Check for saved theme preference or default to light mode
        const currentTheme = localStorage.getItem('theme') || 'light';
        if (currentTheme === 'dark') {
            document.body.classList.add('dark');
            themeIcon.textContent = '◐';
        }
        
        function toggleDarkMode() {
            document.body.classList.toggle('dark');
            const isDark = document.body.classList.contains('dark');
            themeIcon.textContent = isDark ? '◐' : '◑';
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }
        
        darkModeToggle.addEventListener('click', toggleDarkMode);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when typing in input fields
            if (e.target.tagName === 'INPUT') return;
            
            const key = e.key.toLowerCase();
            
            // Number keys 1-9, 0 for shapes
            if (key >= '1' && key <= '9') {
                const shapeIndex = parseInt(key) - 1;
                if (shapeIndex < SHAPES.length) {
                    const shape = SHAPES[shapeIndex];
                    selectShape(shape);
                    e.preventDefault();
                }
            } else if (key === '0') {
                // 0 key for the 10th shape (Right)
                if (SHAPES.length >= 10) {
                    const shape = SHAPES[9];
                    selectShape(shape);
                    e.preventDefault();
                }
            }
            // P for Place mode
            else if (key === 'p') {
                currentTool = 'place';
                currentTemplate = null;  // Clear stamp
                document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                document.querySelector('[data-tool="place"]').classList.add('active');
                renderShapeInventory();  // Update stamp highlights
                e.preventDefault();
            }
            // E for Erase mode
            else if (key === 'e') {
                currentTool = 'erase';
                currentTemplate = null;  // Clear stamp
                document.querySelectorAll('.tool-button').forEach(b => b.classList.remove('active'));
                document.querySelector('[data-tool="erase"]').classList.add('active');
                renderShapeInventory();  // Update stamp highlights
                e.preventDefault();
            }
            // C for Clear (with confirmation)
            else if (key === 'c') {
                if (confirm('Are you sure you want to clear the canvas?')) {
                    initGrid();
                }
                e.preventDefault();
            }
            // D for Dark mode toggle
            else if (key === 'd') {
                toggleDarkMode();
                e.preventDefault();
            }
            // Ctrl+Z for Undo
            else if ((e.ctrlKey || e.metaKey) && key === 'z' && !e.shiftKey) {
                undo();
                e.preventDefault();
            }
            // Ctrl+Y or Ctrl+Shift+Z for Redo
            else if ((e.ctrlKey || e.metaKey) && (key === 'y' || (key === 'z' && e.shiftKey))) {
                redo();
                e.preventDefault();
            }
        });

        // Handle brick click
        function handleBrickClick(index, remove = false) {
            wasDrawing = true;
            const brick = canvas.children[index];
            
            if (remove || currentTool === 'erase') {
                // Remove brick
                brick.className = 'brick empty';
                brick.style.backgroundColor = '';
                brick.style.borderColor = '';
                // Apply custom empty brick colors if set
                if (window.emptyBrickColor) {
                    brick.style.backgroundColor = window.emptyBrickColor;
                    brick.style.borderColor = window.emptyBrickBorder;
                }
                brick.classList.remove('shadow-brick');
                grid[index] = { color: null, shape: null, isShadow: false };
            } else if (currentTemplate) {
                // Place stamp
                placeTemplate(index);
            } else {
                // Place single brick
                brick.className = `brick ${currentShape.class}`;
                brick.style.backgroundColor = currentColor.hex;
                brick.classList.remove('shadow-brick');
                grid[index] = { 
                    color: currentColor,
                    shape: currentShape,
                    isShadow: false
                };
            }
            
            updateStats();
        }

        // Place stamp at position
        function placeTemplate(startIndex) {
            if (!currentTemplate || !currentTemplate.pattern) return;
            
            const startRow = Math.floor(startIndex / gridWidth);
            const startCol = startIndex % gridWidth;
            
            currentTemplate.pattern.forEach(brick => {
                const targetRow = startRow + brick.row;
                const targetCol = startCol + brick.col;
                
                if (targetRow >= 0 && targetRow < gridHeight && targetCol >= 0 && targetCol < gridWidth) {
                    const targetIndex = targetRow * gridWidth + targetCol;
                    const targetBrick = canvas.children[targetIndex];
                    
                    if (brick.color && brick.shape) {
                        targetBrick.className = `brick ${brick.shape.class}`;
                        // Use currently selected color instead of stamp's saved color
                        targetBrick.style.backgroundColor = currentColor.hex;
                        grid[targetIndex] = {
                            color: currentColor,  // Use current color
                            shape: brick.shape,
                            isShadow: false
                        };
                    }
                }
            });
            
            updateStats();
        }

        // Add shadows to all bricks
        function addShadowsToAllBricks() {
            // First, remove any existing shadow bricks
            for (let i = 0; i < grid.length; i++) {
                if (grid[i].isShadow) {
                    const brick = canvas.children[i];
                    brick.className = 'brick empty';
                    brick.style.backgroundColor = '';
                    brick.style.borderColor = '';
                    // Apply custom empty brick colors if set
                    if (window.emptyBrickColor) {
                        brick.style.backgroundColor = window.emptyBrickColor;
                        brick.style.borderColor = window.emptyBrickBorder;
                    }
                    brick.classList.remove('shadow-brick');
                    grid[i] = { color: null, shape: null, isShadow: false };
                }
            }
            
            // Create a set of all placed brick positions
            const placedBricks = new Set();
            for (let i = 0; i < grid.length; i++) {
                if (grid[i].color !== null && !grid[i].isShadow) {
                    placedBricks.add(i);
                }
            }
            
            // Find all positions that should have shadows (only bottom-right for drop shadow effect)
            const shadowPositions = new Set();
            
            placedBricks.forEach(index => {
                const row = Math.floor(index / gridWidth);
                const col = index % gridWidth;
                
                // Only check bottom-left positions for drop shadow effect
                const offsets = [
                    [0, -1],   // left
                    [1, 0],    // bottom
                    [1, -1]    // bottom-left diagonal
                ];
                
                offsets.forEach(([rowOffset, colOffset]) => {
                    const newRow = row + rowOffset;
                    const newCol = col + colOffset;
                    
                    if (newRow >= 0 && newRow < gridHeight && newCol >= 0 && newCol < gridWidth) {
                        const newIndex = newRow * gridWidth + newCol;
                        
                        // Only add shadow if position is empty (not a placed brick)
                        if (!placedBricks.has(newIndex) && grid[newIndex].color === null) {
                            shadowPositions.add(newIndex);
                        }
                    }
                });
            });
            
            // Place shadow bricks at all shadow positions
            shadowPositions.forEach(index => {
                const shadowBrick = canvas.children[index];
                shadowBrick.className = `brick brick-full shadow-brick`;
                shadowBrick.style.backgroundColor = shadowColor;
                grid[index] = {
                    color: { hex: shadowColor, name: 'Shadow' },
                    shape: SHAPES[0], // Full shape
                    isShadow: true
                };
            });
            
            updateStats();
        }

        // Place shadow bricks around a main brick (not used anymore, kept for compatibility)
        function placeShadowBricks(centerIndex) {
            // This function is kept for compatibility but not used
            // Shadows are now added for all bricks at once via addShadowsToAllBricks()
        }

        // Update stats
        function updateStats() {
            const total = gridWidth * gridHeight;
            const placed = grid.filter(cell => cell.color !== null).length;
            const empty = total - placed;
            
            document.getElementById('total-bricks').textContent = total;
            document.getElementById('placed-bricks').textContent = placed;
            document.getElementById('empty-bricks').textContent = empty;
        }

        // Slider updates
        widthSlider.addEventListener('input', (e) => {
            widthValue.textContent = e.target.value;
        });

        heightSlider.addEventListener('input', (e) => {
            heightValue.textContent = e.target.value;
        });

        // Apply size
        document.getElementById('apply-size-btn').addEventListener('click', () => {
            const newWidth = parseInt(widthSlider.value);
            const newHeight = parseInt(heightSlider.value);
            
            // Check if we're increasing size (preserve data) or decreasing (warn user)
            if (newWidth < gridWidth || newHeight < gridHeight) {
                if (!confirm('Decreasing grid size may crop your design. Continue?')) {
                    return;
                }
            }
            
            // Save current grid data
            const oldGrid = [...grid];
            const oldWidth = gridWidth;
            const oldHeight = gridHeight;
            
            // Update dimensions
            gridWidth = newWidth;
            gridHeight = newHeight;
            
            // Create new grid with empty cells
            grid = [];
            canvas.innerHTML = '';
            
            const isMobile = window.innerWidth <= 768;
            const brickSize = isMobile ? 24 : 32;
            canvas.style.gridTemplateColumns = `repeat(${gridWidth}, ${brickSize}px)`;
            
            // Create all bricks
            for (let i = 0; i < gridHeight * gridWidth; i++) {
                const brick = document.createElement('div');
                brick.className = 'brick empty';
                brick.dataset.index = i;
                
                // Apply custom empty brick colors if set
                if (window.emptyBrickColor) {
                    brick.style.backgroundColor = window.emptyBrickColor;
                    brick.style.borderColor = window.emptyBrickBorder;
                }
                
                brick.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    isMouseDown = true;
                    handleBrickClick(i, e.button === 2);
                });
                
                brick.addEventListener('mouseenter', () => {
                    if (isMouseDown) {
                        handleBrickClick(i, currentTool === 'erase');
                    }
                });
                
                brick.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    handleBrickClick(i, true);
                });
                
                canvas.appendChild(brick);
                grid.push({ color: null, shape: null });
            }
            
            // Restore old data where it fits
            for (let y = 0; y < Math.min(oldHeight, gridHeight); y++) {
                for (let x = 0; x < Math.min(oldWidth, gridWidth); x++) {
                    const oldIndex = y * oldWidth + x;
                    const newIndex = y * gridWidth + x;
                    
                    if (oldGrid[oldIndex] && oldGrid[oldIndex].color) {
                        const cellData = oldGrid[oldIndex];
                        const brick = canvas.children[newIndex];
                        brick.className = `brick ${cellData.shape.class}`;
                        brick.style.backgroundColor = cellData.color.hex;
                        grid[newIndex] = cellData;
                    }
                }
            }
            
            updateStats();
            saveState();
        });

        // Clear canvas
        document.getElementById('clear-btn').addEventListener('click', () => {
            if (confirm('Are you sure you want to clear the canvas?')) {
                initGrid();
                saveState();
            }
        });

        // Fill all
        document.getElementById('fill-btn').addEventListener('click', () => {
            for (let i = 0; i < grid.length; i++) {
                const brick = canvas.children[i];
                brick.className = `brick ${currentShape.class}`;
                brick.style.backgroundColor = currentColor.hex;
                grid[i] = {
                    color: currentColor,
                    shape: currentShape
                };
            }
            updateStats();
            saveState();
        });

        // Recolor all placed bricks
        document.getElementById('recolor-btn').addEventListener('click', () => {
            let recoloredCount = 0;
            for (let i = 0; i < grid.length; i++) {
                if (grid[i].color !== null) {
                    const brick = canvas.children[i];
                    // Keep the same shape, just change the color
                    brick.className = `brick ${grid[i].shape.class}`;
                    brick.style.backgroundColor = currentColor.hex;
                    grid[i].color = currentColor;
                    recoloredCount++;
                }
            }
            updateStats();
            if (recoloredCount > 0) {
                console.log(`Recolored ${recoloredCount} bricks to ${currentColor.name}`);
                saveState();
            }
        });

        // Fill only empty slots with current color/shape
        document.getElementById('fill-empty-btn').addEventListener('click', () => {
            let filledCount = 0;
            for (let i = 0; i < grid.length; i++) {
                if (grid[i].color === null) {
                    const brick = canvas.children[i];
                    brick.className = `brick ${currentShape.class}`;
                    brick.style.backgroundColor = currentColor.hex;
                    grid[i] = {
                        color: currentColor,
                        shape: currentShape
                    };
                    filledCount++;
                }
            }
            updateStats();
            if (filledCount > 0) {
                console.log(`Filled ${filledCount} empty slots with ${currentColor.name}`);
                saveState();
            }
        });

        // Export design as PNG
        document.getElementById('export-png-btn').addEventListener('click', () => {
            const brickSize = 32; // Fixed size for export
            const gap = 1; // Gap between tiles
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = gridWidth * brickSize + (gridWidth - 1) * gap;
            exportCanvas.height = gridHeight * brickSize + (gridHeight - 1) * gap;
            const ctx = exportCanvas.getContext('2d');
            
            // Get baseplate color or use default
            const computedStyle = getComputedStyle(document.documentElement);
            const bgColor = baseplateColor || computedStyle.getPropertyValue('--bg-tertiary').trim();
            
            // Fill background with baseplate color
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            // Draw each brick
            for (let i = 0; i < grid.length; i++) {
                const cell = grid[i];
                const row = Math.floor(i / gridWidth);
                const col = i % gridWidth;
                const x = col * (brickSize + gap);
                const y = row * (brickSize + gap);
                
                if (cell.color && cell.shape) {
                    ctx.fillStyle = cell.color.hex;
                    
                    // Draw brick with shape (rounded corners based on shape class)
                    const shapeClass = cell.shape.class;
                    ctx.beginPath();
                    
                    if (shapeClass === 'brick-circle') {
                        // Draw circle
                        ctx.arc(x + brickSize / 2, y + brickSize / 2, brickSize / 2, 0, Math.PI * 2);
                    } else {
                        // Determine corner radii based on shape
                        let radii = [3, 3, 3, 3]; // [topLeft, topRight, bottomRight, bottomLeft]
                        const fullRadius = brickSize * 0.5; // 50% for rounded corners
                        
                        if (shapeClass === 'brick-tl') radii = [fullRadius, 3, 3, 3];
                        else if (shapeClass === 'brick-tr') radii = [3, fullRadius, 3, 3];
                        else if (shapeClass === 'brick-br') radii = [3, 3, fullRadius, 3];
                        else if (shapeClass === 'brick-bl') radii = [3, 3, 3, fullRadius];
                        else if (shapeClass === 'brick-t') radii = [fullRadius, fullRadius, 3, 3];
                        else if (shapeClass === 'brick-b') radii = [3, 3, fullRadius, fullRadius];
                        else if (shapeClass === 'brick-l') radii = [fullRadius, 3, 3, fullRadius];
                        else if (shapeClass === 'brick-r') radii = [3, fullRadius, fullRadius, 3];
                        
                        // Draw rounded rectangle
                        ctx.moveTo(x + radii[0], y);
                        ctx.lineTo(x + brickSize - radii[1], y);
                        ctx.quadraticCurveTo(x + brickSize, y, x + brickSize, y + radii[1]);
                        ctx.lineTo(x + brickSize, y + brickSize - radii[2]);
                        ctx.quadraticCurveTo(x + brickSize, y + brickSize, x + brickSize - radii[2], y + brickSize);
                        ctx.lineTo(x + radii[3], y + brickSize);
                        ctx.quadraticCurveTo(x, y + brickSize, x, y + brickSize - radii[3]);
                        ctx.lineTo(x, y + radii[0]);
                        ctx.quadraticCurveTo(x, y, x + radii[0], y);
                    }
                    
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Draw empty brick with lighter color
                    const emptyColor = window.emptyBrickColor || lightenColor(bgColor, 30);
                    ctx.fillStyle = emptyColor;
                    ctx.fillRect(x, y, brickSize, brickSize);
                    
                    // Draw border
                    const borderColor = window.emptyBrickBorder || lightenColor(bgColor, 20);
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, brickSize, brickSize);
                }
            }
            
            // Convert to PNG and download
            exportCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'brickz-design.png';
                a.click();
                URL.revokeObjectURL(url);
            }, 'image/png');
        });

        // Export design
        document.getElementById('export-btn').addEventListener('click', () => {
            const design = {
                width: gridWidth,
                height: gridHeight,
                grid: grid.map(cell => ({
                    color: cell.color ? cell.color.hex : null,
                    colorClass: cell.color ? cell.color.class : null,
                    shape: cell.shape ? cell.shape.class : null,
                    shapeId: cell.shape ? cell.shape.id : null
                }))
            };
            
            const blob = new Blob([JSON.stringify(design, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'brickz-design.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        // Import design
        document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });

        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const design = JSON.parse(event.target.result);
                    
                    // Apply grid size
                    gridWidth = design.width;
                    gridHeight = design.height;
                    widthSlider.value = gridWidth;
                    heightSlider.value = gridHeight;
                    widthValue.textContent = gridWidth;
                    heightValue.textContent = gridHeight;
                    
                    // Initialize grid
                    initGrid();
                    
                    // Apply design
                    design.grid.forEach((cell, index) => {
                        if (cell.color && cell.shape) {
                            let color = COLORS.find(c => c.hex === cell.color);
                            // If color not found, add it
                            if (!color) {
                                color = { name: 'Imported', hex: cell.color, class: '' };
                                COLORS.push(color);
                            }
                            const shape = SHAPES.find(s => s.class === cell.shape);
                            
                            if (color && shape) {
                                const brick = canvas.children[index];
                                brick.className = `brick ${shape.class}`;
                                brick.style.backgroundColor = color.hex;
                                grid[index] = { color, shape };
                            }
                        }
                    });
                    
                    renderColorPalette();
                    renderQuickColorPalette();
                    saveColors();
                    updateStats();
                    saveState();
                    alert('Design imported successfully!');
                } catch (error) {
                    alert('Error importing design: ' + error.message);
                }
            };
            reader.readAsText(file);
            
            // Reset input
            e.target.value = '';
        });

        // Import image
        document.getElementById('import-image-btn').addEventListener('click', () => {
            document.getElementById('image-input').click();
        });

        document.getElementById('image-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    processImage(img);
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            
            // Reset input
            e.target.value = '';
        });

        function processImage(img) {
            // Create a canvas to read pixel data
            const tempCanvas = document.createElement('canvas');
            const ctx = tempCanvas.getContext('2d');
            
            // Scale image to fit grid
            tempCanvas.width = gridWidth;
            tempCanvas.height = gridHeight;
            
            // Draw image scaled to canvas size
            ctx.drawImage(img, 0, 0, gridWidth, gridHeight);
            
            // Get pixel data
            const imageData = ctx.getImageData(0, 0, gridWidth, gridHeight);
            const pixels = imageData.data;
            
            // Clear current grid
            initGrid();
            
            // Convert pixels to brickz bricks
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    const index = y * gridWidth + x;
                    const pixelIndex = (y * gridWidth + x) * 4;
                    
                    const r = pixels[pixelIndex];
                    const g = pixels[pixelIndex + 1];
                    const b = pixels[pixelIndex + 2];
                    const a = pixels[pixelIndex + 3];
                    
                    // Skip transparent pixels
                    if (a < 128) continue;
                    
                    // Find closest color
                    const color = findClosestColor(r, g, b);
                    
                    if (color) {
                        const brick = canvas.children[index];
                        brick.className = `brick ${currentShape.class}`;
                        brick.style.backgroundColor = color.hex;
                        grid[index] = { color, shape: currentShape };
                    }
                }
            }
            
            updateStats();
            saveState();
            alert('Image imported! Adjust grid size before importing if you want different dimensions.');
        }

        function findClosestColor(r, g, b) {
            let minDistance = Infinity;
            let closestColor = null;
            
            COLORS.forEach(color => {
                // Convert hex to RGB
                const hex = color.hex.replace('#', '');
                const cr = parseInt(hex.substr(0, 2), 16);
                const cg = parseInt(hex.substr(2, 2), 16);
                const cb = parseInt(hex.substr(4, 2), 16);
                
                // Calculate color distance (Euclidean distance in RGB space)
                const distance = Math.sqrt(
                    Math.pow(r - cr, 2) +
                    Math.pow(g - cg, 2) +
                    Math.pow(b - cb, 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            });
            
            return closestColor;
        }

        // Export stamps
        document.getElementById('export-shapes-btn').addEventListener('click', () => {
            const shapesData = {
                stamps: customTemplates
            };
            
            const blob = new Blob([JSON.stringify(shapesData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'brickz-stamps.json';
            a.click();
            URL.revokeObjectURL(url);
        });

        // Import stamps
        document.getElementById('import-shapes-btn').addEventListener('click', () => {
            document.getElementById('shapes-input').click();
        });

        document.getElementById('shapes-input').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (files.length === 0) return;
            
            let totalImported = 0;
            let errorFiles = [];
            
            // Process all files
            for (const file of files) {
                try {
                    const text = await file.text();
                    const shapesData = JSON.parse(text);
                    
                    // Support both "stamps" and "templates" for backwards compatibility
                    const stamps = shapesData.stamps || shapesData.templates;
                    
                    if (stamps && Array.isArray(stamps)) {
                        customTemplates = [...customTemplates, ...stamps];
                        totalImported += stamps.length;
                    } else {
                        errorFiles.push(file.name);
                    }
                } catch (error) {
                    errorFiles.push(file.name);
                }
            }
            
            // Update UI
            renderShapeInventory();
            saveTemplates();
            
            // Show results
            let message = `Imported ${totalImported} stamp(s) from ${files.length} file(s)!`;
            if (errorFiles.length > 0) {
                message += `\n\nFailed to import: ${errorFiles.join(', ')}`;
            }
            alert(message);
            
            // Reset input
            e.target.value = '';
        });


        // Handle window resize for responsive grid
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                const isMobile = window.innerWidth <= 768;
                const brickSize = isMobile ? 24 : 32;
                canvas.style.gridTemplateColumns = `repeat(${gridWidth}, ${brickSize}px)`;
            }, 250);
        });

        // Shadow functionality
        let shadowColor = localStorage.getItem('shadowColor') || '#000000';
        document.getElementById('shadow-color-preview').style.background = shadowColor;
        
        // Add shadows button
        document.getElementById('add-shadows-btn').addEventListener('click', () => {
            addShadowsToAllBricks();
            saveState();
        });
        
        // Shadow color picker
        document.getElementById('shadow-color-btn').addEventListener('click', () => {
            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.value = shadowColor;
            colorInput.style.display = 'none';
            document.body.appendChild(colorInput);
            
            colorInput.addEventListener('change', (e) => {
                shadowColor = e.target.value;
                document.getElementById('shadow-color-preview').style.background = shadowColor;
                localStorage.setItem('shadowColor', shadowColor);
                
                // Update all existing shadow bricks with new color
                for (let i = 0; i < grid.length; i++) {
                    if (grid[i].isShadow) {
                        const brick = canvas.children[i];
                        brick.style.backgroundColor = shadowColor;
                        grid[i].color.hex = shadowColor;
                    }
                }
                
                document.body.removeChild(colorInput);
            });
            
            colorInput.addEventListener('blur', () => {
                document.body.removeChild(colorInput);
            });
            
            colorInput.click();
        });

        // Function to lighten a color
        function lightenColor(hex, percent = 30) {
            // Convert hex to RGB
            const num = parseInt(hex.replace('#', ''), 16);
            const r = (num >> 16);
            const g = (num >> 8) & 0x00FF;
            const b = num & 0x0000FF;
            
            // Lighten by moving towards white
            const newR = Math.min(255, Math.floor(r + (255 - r) * (percent / 100)));
            const newG = Math.min(255, Math.floor(g + (255 - g) * (percent / 100)));
            const newB = Math.min(255, Math.floor(b + (255 - b) * (percent / 100)));
            
            // Convert back to hex
            return '#' + ((newR << 16) | (newG << 8) | newB).toString(16).padStart(6, '0');
        }
        
        // Function to update empty brick colors based on baseplate color
        function updateEmptyBrickColors(baseColor) {
            const lighterColor = lightenColor(baseColor, 30);
            const borderColor = lightenColor(baseColor, 20);
            
            // Update all empty bricks
            const emptyBricks = document.querySelectorAll('.brick.empty');
            emptyBricks.forEach(brick => {
                brick.style.backgroundColor = lighterColor;
                brick.style.borderColor = borderColor;
            });
            
            // Store colors for new bricks
            window.emptyBrickColor = lighterColor;
            window.emptyBrickBorder = borderColor;
        }
        
        // Baseplate color functionality
        let baseplateColor = localStorage.getItem('baseplateColor') || null;
        const gridContainer = document.querySelector('.grid-container');
        
        // Apply saved baseplate color on load
        if (baseplateColor) {
            gridContainer.style.background = baseplateColor;
            document.getElementById('baseplate-color-preview').style.background = baseplateColor;
            updateEmptyBrickColors(baseplateColor);
        } else {
            // Set preview to current CSS variable color
            const computedStyle = getComputedStyle(document.documentElement);
            const defaultColor = computedStyle.getPropertyValue('--bg-tertiary').trim();
            document.getElementById('baseplate-color-preview').style.background = defaultColor;
        }
        
        // Baseplate color picker
        document.getElementById('baseplate-color-btn').addEventListener('click', () => {
            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.value = baseplateColor || '#f1f5f9';
            colorInput.style.display = 'none';
            document.body.appendChild(colorInput);
            
            colorInput.addEventListener('change', (e) => {
                baseplateColor = e.target.value;
                gridContainer.style.background = baseplateColor;
                document.getElementById('baseplate-color-preview').style.background = baseplateColor;
                localStorage.setItem('baseplateColor', baseplateColor);
                
                // Update empty brick colors
                updateEmptyBrickColors(baseplateColor);
                
                document.body.removeChild(colorInput);
            });
            
            colorInput.addEventListener('blur', () => {
                if (document.body.contains(colorInput)) {
                    document.body.removeChild(colorInput);
                }
            });
            
            colorInput.click();
        });

        // Clear all stamps
        document.getElementById('clear-stamps-btn').addEventListener('click', () => {
            if (customTemplates.length === 0) {
                alert('No stamps to clear!');
                return;
            }
            
            if (confirm(`Are you sure you want to delete all ${customTemplates.length} stamp(s)? This cannot be undone.`)) {
                customTemplates = [];
                currentTemplate = null;
                saveTemplates();
                renderShapeInventory();
                alert('All stamps cleared!');
            }
        });

        // Save current canvas as stamp
        document.getElementById('save-template-btn').addEventListener('click', () => {
            const name = prompt('Enter a name for this stamp:');
            if (!name) return;
            
            // Get all non-empty bricks
            const pattern = [];
            for (let i = 0; i < grid.length; i++) {
                if (grid[i].color !== null && !grid[i].isShadow) {
                    const row = Math.floor(i / gridWidth);
                    const col = i % gridWidth;
                    pattern.push({
                        row,
                        col,
                        color: grid[i].color,
                        shape: grid[i].shape
                    });
                }
            }
            
            if (pattern.length === 0) {
                alert('Canvas is empty! Add some bricks first.');
                return;
            }
            
            // Normalize pattern to start at 0,0
            const minRow = Math.min(...pattern.map(p => p.row));
            const minCol = Math.min(...pattern.map(p => p.col));
            const normalizedPattern = pattern.map(p => ({
                row: p.row - minRow,
                col: p.col - minCol,
                color: p.color,
                shape: p.shape
            }));
            
            customTemplates.push({
                name,
                pattern: normalizedPattern,
                width: Math.max(...normalizedPattern.map(p => p.col)) + 1,
                height: Math.max(...normalizedPattern.map(p => p.row)) + 1
            });
            
            saveTemplates();
            renderShapeInventory();
            alert(`Stamp "${name}" saved! Click it in the inventory to place it on canvas.`);
        });

        // Initialize
        initGrid();
        saveState();
        updateUndoRedoButtons();
    </script>
</body>
</html>

